# 면접 질문 


## 1. 공유 메모리 기반 IPC가 소켓 통신보다 빠른이뉴는?
공유 메모리는 동일한 메모리 공간에서 직접 접근하여 데이털르 주고 받고, 마치 자신으 메모리 공간을 읽고 쓰는 것처럼 진행되기 때문에 소켓 통신보다 빠르다.
소켓 통신은 커널을 통해 데이터를 주고 받으므로 오버헤드가 발생할 수 있으며, IPC보다 다소 느리다.

## 2. 운영체제가 메모리에 적재되기까지의 과정

1. 전원이 켜지면 CPU는 ROM에 저장된 BIOS를 실행한다.
2. BIOS는 하드웨어를 검사하는 POST 수행 후, 하드 디스크의 MBR을 읽어 부트 로더를 로드한다.
3. 부트 로더가 커널의 위치를 찾아 RAM에 적재하여 커널이 메모리에 업로드된다.

## 3. 운영체제에서 커널이란?

커널은 운영체제의 핵심 부분이다. 컴퓨터 하드웨어와 응용 프로그램 사이에서 중재자 역할을 한다.
프로세스와 스레드가 정상적으로 실행될 수 있도록 보조하고, 이들이 CPU,메모리,보조기억장치 등의 하드웨어를 공정하게 할당받아 실행되도로 ㄱ한다.
커널은 이중 모드를 운영하여 사용자 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 한다.

## 4. 스레드 세이프 메서드를 동기화하지 않으면 어떤 문제가 발생하는가?
레이스 컨디션이 발생한다. 여러 스레드가 동시에 실행하면서 데이터의 일관성이 지켜지지 않으며 추가적인 동기화 방법을 적용하여 스레드 세이프한 메서드를 사용해야 한다.
방법으로는 java에서 synchrnoized, 뮤텍스, 세마포를 통한 락을 걸 수 있다.

## 5. 지나친 문맥 교환시 발생하는 문제점은?
빈번한 문맥 교환은 문맥 교환시 발생하는 데이터 저장 및 복구 과정에서 PCB를 불러오고 읽는시간, CPU 시간을 사용하게 되므로 효율성이 떨어진다.
캐시 메모리의 데이터를 반복적으로 무효화 시키므로 캐시 미스가 빈번하게 발생할 수 있으며, 캐시 미스와 문맥 교환 오버헤드로 인한 전체 시스템의 처리 속도가 저하 될 수 있다.

## 6. 10GB의 큰 프로그램을 수행해야 하지만 현재 8GB의 물리 메모리공간이 있다. 실행할 수 있는가?
실행할 수 있다. 프로세스가 필요한 메모리 공간을 가상 주소로 할당하고, 실제 물리 메모리에는 필요한 부분만 적재한다.
필요하지 않은 부분은 디스크의 스왑 영역에 젖아하고, 필요할 떄 물리 메모리에 적재할 수 있다.


## 7. 페이지 폴트의 과정을 설명하시오
1. CPU가 기존의 작업 내역을 백업
2. 페이지 폴트 처리 루틴을 실행
3. 메모리로 원하는 페이지를 가져와 유효 비트를 1로 변경한다.
4. 페이지 폴트를 처리하면 CPU가 해당 페이지에 접근할 수 있다.

## 8. 메모리 누수가 어디서 발생할 수 있고, 처리할 수 있는 방법은?
할당받은 메모리를 해제하지 않아 메모리를 지속적으로 점유하고 있는 상태를 말한다. 이는 캐시, 가비지 컬렉션이 관리하지 않는 스태틱영역 등에서 발생할 수 있다.
캐시는 일정한 시간과 값을 부여하고 시간이 지날수록 값을 감소하게 하여 0에 도달하면 소멸하도록 설정하는 방법이 있다.
또한 객체들은 모두 사용시 null값을 부여하여 메모리를 해제할 수 있다. try-catch-finally에서 finally에 명시하거나 @BeforeDestroy등의 어노테이션으로 라이프사이클을 관리할 수 있다.

## 9. 스레드를 생성하고 실행할 때 join메서드에 대해 설명하시오
join은 생성된 스레드의 실행이 완료될때까지 대기하게 만드는 메서드이다.
생성된 스레드의 실행이 종료되기도 전에 해당 스레드를 생성한 스레드가 종료되거나 다음 작업을 수행하는 것을 방지할 수 있다.

## 10. 동일한 코드를 여러 프로세스로 실행하는 것과 여러 스레드를 통한 프로세스를 실행하는 것은 어떤 차이가 있는가?

차이점은 자원 공유 여부에 있다. 프로세스간에는 독립적으로 수행되며 메모리, 파일 등의 자원을 공유하지 않는다. 반면 여러 스레드로 프로세스를 실행하는 경우, 동일한 프로세스 내에서 실행되므로 자원을 공유한다.
스레드 간에는 통신과 협업이 쉽지만, 자원을 공유하기 때문에 하나의 스레드만 문제가 생겨도 전체 스레드에 영향을 줄 수 있다.
프로세스는 독립적이기 때문에 하나의 프로세스에 문제가 생겨도 다른 프로세스들은 정상적으로 수행된다.

## 11. 교착 상태가 무엇이고 왜 발생 하는가?
2개 이상의 프로세스가 서로 상대방의 자원을 기다리면서 무한 대기를 하는 상태에 걸린것을 말한다.
이에는 네 가지 조건이 충족될 떄 발생한다.
1. 자원의 상호 배제
2. 이미 자원을 서로 점유한 상태
3. 자원의 비선점 형태
4. 원형 대기인 경우

## 12. 그럼 이를 해결하기 위한 방법은 어떤 방법이 존재하는가?
각 메모리에 접근시 순서대로 접근이 가능하도록 번호를 메기고 번호보다 더 낮은 메모리에 접근할 경우 접근을 못하게 하는 방법
교착 상태를 감지하여 하나의 프로세스를 강제로 종료하고 마치게 한뒤 다시 실행시키는 방법
은행 알고리즘을 통해 교착 상태가 일어나지 않도록 안전한 순서열을 형성하고 충분한 메모리를 준비해두는 상태를 만든다.
등이 있다.

## 13. 블로킹 입출력과 논 블로킹 입출력에 대해 설명하시오
블로킹과 논 블로킹의 차이점은 프로세스가 입출력 작업을 수행할 때 대기하는가에 대한 여부이다.
블로킹 입출력에서는 해당 작업이 완료될 때까지 다른 작업을 할 수 없으며, 논 블로킹 입출력에서는 프로세스가 입출력 작업을 하고 있는 동안에도 다음 명령을 수행할 수 있다.

## 14. 디버깅할 때 주로 볼 수 있는 주소는 실제 물리 주소인가?
아니다. 가상 메모리를 사용한 논리 주소이기 때문에 실제 메모리 주소와 다르다. 프로세스를 실행하는 CPU나 메모리에 적재된 프로세스 입장에서는 메모리 내에 물리 주소를 모두 알기 어렵기 때문에
프로세스 마다 부여되는 가상 주소를 활용한다.
이 가상 주소는 CPU와 메모리 사이에 위치하는 MMU(Memory Management Unit)에 의해 물리 주소로 변환된다.

## 15. 메모리가 부족하면 어떤 현상이 발생할 수 있는가?
메모리가 부족하면 운영체제는 부족한 메모리를 보완하기 위해 디스크에 메모리 페이지를 저장하고, 필요할 떄 다시 불러오는 스왑 과정을 사용한다.
과도한 스와핑은 스래싱이라는 현상이 발생할 수 있으며, 지속적으로 디스크 I/O에만 몰두 하게 되어 실질적인 작업 처리가 이뤄지지 않는다.


## 소스 코들르 실행한 후 'Segmentation fault'라는 메시지와 함께 코드가 작동하지 않는 경우 어떻게 해야 하는가?
비정상 종료시에는 이전 작업의 정볼르 저장한 덤프 파일이 생성된다. 생성된 덤프 파일을 분석하여 문제의 원인을 파악한다.
스택 트레이스가 포함도어 있는 경우, 문제가 발생한 순간의 함수 호출 관계를 통해 원인을 추적할 수 있다.

## 프로세스의 페이지 테이블이 모두 메모리에 적재될 경우 발생할 수 있는 문제점과 해결방안은?
메모리 접근 횟수가 두 배 늘어난다. 왜냐하면 페이지 테입르을 접근하고 실제 데이터 값을 찾기 위해 두 번 조회하기 때문이다. 
또 페이지 테이블이 차지하는 메모리 용량이 커져 비효율적이다. 이때는 페이지 테이블중 자주 조회되는 부분을 캐싱하거나, 계층적 페이지 기법을 사용하여
페이지 테이블을 나누어 관리하면 메모리 접근 횟수와 메모리 사용량을 줄일 수 있다.

## 가상 머신과 컨테이너의 차이점은?
가상 머신은 하이퍼바이저를 통해 물리 하드웨어 위에서 여러 운영체제를 독립적으로 실행시킨다.
각 가상 머신은 전체 운영체제와 가상 하드웨어를 포함하기 때문에 상대적으로 무겁다.
반대로 컨테이너는 기본적으로 커널을 공유하고 실행하는 특정 애프리케이션을 위한 격리성을 제공하므로 경량화의 특징을 갖고있어 가볍고 빠르다.
